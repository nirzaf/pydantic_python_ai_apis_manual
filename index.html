<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intelligent APIs: Serving AI Models Seamlessly with Pydantic and Python Frameworks</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-tomorrow.min.css">
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.0.0/css/all.min.css">
    <style>
        :root {
            --primary-color: #1976d2;
            --primary-dark: #0d47a1;
            --accent-color: #dd0031;
            --text-color: #333;
            --text-light: #767676;
            --bg-color: #ffffff;
            --bg-sidebar: #fafafa;
            --bg-card: #f5f5f5;
            --code-bg: #f5f5f5;
            --border-color: #e0e0e0;
            --sidebar-width: 280px;
        }

        .dark-mode {
            --primary-color: #42a5f5;
            --primary-dark: #64b5f6;
            --accent-color: #ff4081;
            --text-color: #e0e0e0;
            --text-light: #bdbdbd;
            --bg-color: #121212;
            --bg-sidebar: #1e1e1e;
            --bg-card: #2d2d2d;
            --code-bg: #2d2d2d;
            --border-color: #424242;
        }

        body {
            font-family: 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif;
            color: var(--text-color);
            background-color: var(--bg-color);
            transition: background-color 0.3s, color 0.3s;
            line-height: 1.6;
        }

        .sidebar {
            background-color: var(--bg-sidebar);
            border-right: 1px solid var(--border-color);
            transition: background-color 0.3s;
            width: var(--sidebar-width);
            overflow-y: auto;
        }

        .sidebar-fixed {
            position: fixed;
            top: 0;
            left: 0;
            height: 100vh;
            z-index: 10;
        }

        .sidebar-content {
            padding: 1rem;
        }

        .main-content {
            margin-left: var(--sidebar-width);
            padding: 2rem;
            max-width: 1200px;
        }

        @media (max-width: 768px) {
            .sidebar-fixed {
                transform: translateX(-100%);
                transition: transform 0.3s ease;
            }

            .sidebar-open {
                transform: translateX(0);
            }

            .main-content {
                margin-left: 0;
                padding: 1rem;
            }

            .mobile-nav-toggle {
                display: block !important;
            }
        }

        h1,
        h2,
        h3,
        h4,
        h5,
        h6 {
            color: var(--primary-color);
            margin-top: 2rem;
            margin-bottom: 1rem;
            font-weight: 600;
            line-height: 1.3;
        }

        h1 {
            font-size: 2.5rem;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-bottom: 2rem;
        }

        h2 {
            font-size: 2rem;
            margin-top: 3rem;
        }

        h3 {
            font-size: 1.5rem;
            margin-top: 2.5rem;
        }

        h4 {
            font-size: 1.25rem;
            color: var(--text-color);
        }

        p {
            margin-bottom: 1.5rem;
        }

        a {
            color: var(--primary-color);
            text-decoration: none;
            transition: color 0.2s;
        }

        a:hover {
            color: var(--primary-dark);
            text-decoration: underline;
        }

        pre {
            background-color: var(--code-bg);
            border-radius: 4px;
            padding: 1rem;
            margin: 1.5rem 0;
            overflow-x: auto;
        }

        code {
            font-family: 'Fira Code', Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
            border-radius: 3px;
        }

        .inline-code {
            background-color: var(--code-bg);
            padding: 0.2rem 0.4rem;
            border-radius: 3px;
            font-size: 0.9em;
        }

        .card {
            background-color: var(--bg-card);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            transition: box-shadow 0.3s, background-color 0.3s;
        }

        .card:hover {
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.15);
        }

        .card-title {
            font-size: 1.3rem;
            font-weight: 600;
            margin-bottom: 1rem;
            color: var(--primary-color);
        }

        .search-box {
            padding: 0.75rem 1rem;
            width: 100%;
            border-radius: 4px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-color);
            color: var(--text-color);
            transition: border-color 0.3s;
        }

        .search-box:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .nav-section {
            margin-bottom: 1rem;
        }

        .nav-section-title {
            font-weight: 600;
            margin-bottom: 0.5rem;
            color: var(--text-light);
            text-transform: uppercase;
            font-size: 0.8rem;
            letter-spacing: 0.05em;
        }

        .nav-item {
            padding: 0.5rem 0;
            display: block;
            color: var(--text-color);
            transition: color 0.2s;
            font-size: 0.9rem;
        }

        .nav-item:hover {
            color: var(--primary-color);
            text-decoration: none;
        }

        .nav-item.active {
            color: var(--primary-color);
            font-weight: 600;
        }

        .child-nav {
            padding-left: 1rem;
            margin-bottom: 0.5rem;
            border-left: 1px solid var(--border-color);
        }

        .theme-toggle {
            background: none;
            border: none;
            color: var(--text-color);
            cursor: pointer;
            font-size: 1.2rem;
            padding: 0.5rem;
            transition: color 0.2s;
        }

        .theme-toggle:hover {
            color: var(--primary-color);
        }

        .badge {
            display: inline-block;
            padding: 0.25rem 0.5rem;
            border-radius: 9999px;
            font-size: 0.75rem;
            font-weight: 600;
            background-color: var(--primary-color);
            color: white;
            margin-left: 0.5rem;
        }

        .note {
            background-color: rgba(25, 118, 210, 0.1);
            border-left: 4px solid var(--primary-color);
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }

        .warning {
            background-color: rgba(255, 193, 7, 0.1);
            border-left: 4px solid #ffc107;
            padding: 1rem;
            margin: 1.5rem 0;
            border-radius: 0 4px 4px 0;
        }

        .mobile-nav-toggle {
            display: none;
            position: fixed;
            top: 1rem;
            left: 1rem;
            z-index: 20;
            background-color: var(--primary-color);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.5rem;
            cursor: pointer;
        }

        .table-of-contents {
            background-color: var(--bg-card);
            border-radius: 8px;
            padding: 1.5rem;
            margin: 2rem 0;
        }

        .toc-title {
            font-weight: 600;
            margin-bottom: 1rem;
            font-size: 1.2rem;
        }

        .toc-item {
            padding: 0.3rem 0;
        }

        .toc-level-2 {
            padding-left: 1rem;
        }

        .toc-level-3 {
            padding-left: 2rem;
        }

        .section-divider {
            border-top: 1px solid var(--border-color);
            margin: 3rem 0;
        }

        .pill {
            display: inline-block;
            padding: 0.25rem 0.75rem;
            border-radius: 9999px;
            font-size: 0.8rem;
            background-color: rgba(25, 118, 210, 0.1);
            color: var(--primary-color);
            margin-right: 0.5rem;
            margin-bottom: 0.5rem;
        }

        ul,
        ol {
            margin-bottom: 1.5rem;
            padding-left: 1.5rem;
        }

        li {
            margin-bottom: 0.5rem;
        }

        blockquote {
            border-left: 4px solid var(--primary-color);
            padding-left: 1rem;
            color: var(--text-light);
            font-style: italic;
            margin: 1.5rem 0;
        }

        img {
            max-width: 100%;
            height: auto;
            border-radius: 4px;
            margin: 1.5rem 0;
        }

        .code-sample {
            position: relative;
        }

        .code-sample .language-badge {
            position: absolute;
            top: 0;
            right: 0;
            padding: 0.25rem 0.5rem;
            background-color: rgba(0, 0, 0, 0.6);
            color: white;
            font-size: 0.75rem;
            border-radius: 0 4px 0 4px;
        }

        .copy-btn {
            position: absolute;
            top: 0.5rem;
            right: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            color: white;
            border: none;
            border-radius: 4px;
            padding: 0.25rem 0.5rem;
            font-size: 0.75rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .copy-btn:hover {
            background: rgba(0, 0, 0, 0.5);
        }

        .header-anchor {
            opacity: 0;
            transition: opacity 0.2s;
            margin-left: 0.5rem;
            font-size: 0.8em;
            color: var(--text-light);
        }

        h2:hover .header-anchor,
        h3:hover .header-anchor,
        h4:hover .header-anchor {
            opacity: 1;
        }

        .chapter-nav {
            display: flex;
            justify-content: space-between;
            margin-top: 3rem;
            padding-top: 1.5rem;
            border-top: 1px solid var(--border-color);
        }

        .chapter-nav-btn {
            display: inline-flex;
            align-items: center;
            background-color: var(--bg-card);
            color: var(--text-color);
            padding: 0.75rem 1rem;
            border-radius: 4px;
            transition: background-color 0.2s, color 0.2s;
        }

        .chapter-nav-btn:hover {
            background-color: var(--primary-color);
            color: white;
            text-decoration: none;
        }

        .progress-bar {
            position: fixed;
            top: 0;
            left: 0;
            height: 3px;
            background-color: var(--accent-color);
            width: 0%;
            z-index: 1000;
            transition: width 0.1s;
        }
    </style>
</head>

<body>
    <div class="progress-bar" id="progress-bar"></div>

    <button class="mobile-nav-toggle" id="mobile-nav-toggle">
        <i class="fas fa-bars"></i>
    </button>

    <aside class="sidebar sidebar-fixed" id="sidebar">
        <div class="sidebar-content">
            <div class="flex items-center justify-between mb-6">
                <h1 class="text-lg font-bold">Intelligent APIs</h1>
                <button class="theme-toggle" id="theme-toggle">
                    <i class="fas fa-moon"></i>
                </button>
            </div>

            <div class="mb-6">
                <input type="text" class="search-box" placeholder="Search..." id="search-box">
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Getting Started</div>
                <a href="#introduction" class="nav-item active">Introduction</a>
                <a href="#preface" class="nav-item">Preface</a>
                <a href="#how-to-use-this-book" class="nav-item">How to Use This Book</a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Part I: Foundations</div>
                <a href="#ch1" class="nav-item">1. The API-Driven AI Revolution</a>
                <div class="child-nav">
                    <a href="#ch1-1" class="nav-item">Evolution of AI Deployment</a>
                    <a href="#ch1-2" class="nav-item">Python Ecosystem</a>
                    <a href="#ch1-3" class="nav-item">Introduction to Pydantic</a>
                </div>

                <a href="#ch2" class="nav-item">2. Pydantic Essentials</a>
                <div class="child-nav">
                    <a href="#ch2-1" class="nav-item">Core Concepts</a>
                    <a href="#ch2-2" class="nav-item">Field Customization</a>
                    <a href="#ch2-3" class="nav-item">Nested Models</a>
                    <a href="#ch2-4" class="nav-item">Settings Management</a>
                </div>

                <a href="#ch3" class="nav-item">3. Designing Your AI API Contract</a>
                <div class="child-nav">
                    <a href="#ch3-1" class="nav-item">Principles of API Design</a>
                    <a href="#ch3-2" class="nav-item">Modeling AI Inputs</a>
                    <a href="#ch3-3" class="nav-item">Modeling AI Outputs</a>
                    <a href="#ch3-4" class="nav-item">Schema Best Practices</a>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Part II: Building APIs</div>
                <a href="#ch4" class="nav-item">4. Building with FastAPI</a>
                <div class="child-nav">
                    <a href="#ch4-1" class="nav-item">Why FastAPI for AI?</a>
                    <a href="#ch4-2" class="nav-item">Request Handling</a>
                    <a href="#ch4-3" class="nav-item">Response Modeling</a>
                    <a href="#ch4-4" class="nav-item">Async and Concurrency</a>
                    <a href="#ch4-5" class="nav-item">Dependency Injection</a>
                </div>
                <a href="#ch5" class="nav-item">5. Alternative Frameworks</a>
                <div class="child-nav">
                    <a href="#ch5-1" class="nav-item">Flask + Pydantic</a>
                    <a href="#ch5-2" class="nav-item">Django DRF + Pydantic</a>
                    <a href="#ch5-3" class="nav-item">Starlette Basics</a>
                    <a href="#ch5-4" class="nav-item">Specialized ML Servers</a>
                </div>
                <a href="#ch6" class="nav-item">6. Advanced Validation</a>
                <div class="child-nav">
                    <a href="#ch6-1" class="nav-item">Custom Validators</a>
                    <a href="#ch6-2" class="nav-item">Root Validators</a>
                    <a href="#ch6-3" class="nav-item">Constrained Types</a>
                    <a href="#ch6-4" class="nav-item">Validation Performance</a>
                </div>
                <a href="#ch7" class="nav-item">7. Security & Authentication</a>
                <div class="child-nav">
                    <a href="#ch7-1" class="nav-item">API Key Authentication</a>
                    <a href="#ch7-2" class="nav-item">OAuth2 and JWT</a>
                    <a href="#ch7-3" class="nav-item">Input Sanitization</a>
                    <a href="#ch7-4" class="nav-item">Rate Limiting</a>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Part III: Advanced</div>
                <a href="#ch8" class="nav-item">8. Integrating AI Model Inference</a>
                <div class="child-nav">
                    <a href="#ch8-1" class="nav-item">Loading Models Efficiently</a>
                    <a href="#ch8-2" class="nav-item">Synchronous vs Async Inference</a>
                    <a href="#ch8-3" class="nav-item">Handling GPU Resources</a>
                    <a href="#ch8-4" class="nav-item">Background Tasks</a>
                </div>
                <a href="#ch9" class="nav-item">9. Serialization Strategies</a>
                <div class="child-nav">
                    <a href="#ch9-1" class="nav-item">Pydantic Serialization Control</a>
                    <a href="#ch9-2" class="nav-item">Custom Encoders/Decoders</a>
                    <a href="#ch9-3" class="nav-item">Working with Binary Data</a>
                    <a href="#ch9-4" class="nav-item">Performance Considerations</a>
                </div>
                <a href="#ch10" class="nav-item">10. Caching & Performance</a>
                <div class="child-nav">
                    <a href="#ch10-1" class="nav-item">Caching Strategies (API Level)</a>
                    <a href="#ch10-2" class="nav-item">Model-Level Caching</a>
                    <a href="#ch10-3" class="nav-item">Profiling and Optimization</a>
                    <a href="#ch10-4" class="nav-item">Load Balancing</a>
                </div>
                <a href="#ch11" class="nav-item">11. Error Handling & Monitoring</a>
                <div class="child-nav">
                    <a href="#ch11-1" class="nav-item">Robust Error Handling</a>
                    <a href="#ch11-2" class="nav-item">Logging Best Practices</a>
                    <a href="#ch11-3" class="nav-item">API Monitoring Tools</a>
                    <a href="#ch11-4" class="nav-item">Alerting on Failures</a>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Part IV: Testing & Deployment</div>
                <a href="#ch12" class="nav-item">12. Testing Your AI API</a>
                <div class="child-nav">
                    <a href="#ch12-1" class="nav-item">Unit Testing Endpoints</a>
                    <a href="#ch12-2" class="nav-item">Integration Testing</a>
                    <a href="#ch12-3" class="nav-item">Testing Model Behavior</a>
                    <a href="#ch12-4" class="nav-item">Performance Testing</a>
                </div>
                <a href="#ch13" class="nav-item">13. API Documentation</a>
                <div class="child-nav">
                    <a href="#ch13-1" class="nav-item">Auto-generated Docs (OpenAPI)</a>
                    <a href="#ch13-2" class="nav-item">Enhancing Documentation</a>
                    <a href="#ch13-3" class="nav-item">Interactive Documentation</a>
                    <a href="#ch13-4" class="nav-item">Keeping Docs Up-to-Date</a>
                </div>
                <a href="#ch14" class="nav-item">14. Versioning & Maintenance</a>
                <div class="child-nav">
                    <a href="#ch14-1" class="nav-item">API Versioning Strategies</a>
                    <a href="#ch14-2" class="nav-item">Schema Evolution</a>
                    <a href="#ch14-3" class="nav-item">Deprecation Policies</a>
                    <a href="#ch14-4" class="nav-item">CI/CD for AI APIs</a>
                </div>
                <a href="#ch15" class="nav-item">15. Deployment Architectures</a>
                <div class="child-nav">
                    <a href="#ch15-1" class="nav-item">Containerization (Docker)</a>
                    <a href="#ch15-2" class="nav-item">Orchestration (Kubernetes)</a>
                    <a href="#ch15-3" class="nav-item">Serverless Deployment</a>
                    <a href="#ch15-4" class="nav-item">Cloud Provider Options</a>
                </div>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Part V: Case Studies</div>
                <a href="#ch16" class="nav-item">16. NLP API Case Study</a>
                <div class="child-nav">
                    <a href="#ch16-1" class="nav-item">Sentiment Analysis API</a>
                    <a href="#ch16-2" class="nav-item">Text Generation API</a>
                    <a href="#ch16-3" class="nav-item">Deployment Considerations</a>
                </div>
                <a href="#ch17" class="nav-item">17. Computer Vision API</a>
                <div class="child-nav">
                    <a href="#ch17-1" class="nav-item">Object Detection API</a>
                    <a href="#ch17-2" class="nav-item">Image Classification API</a>
                    <a href="#ch17-3" class="nav-item">Handling Image Data</a>
                </div>
                <a href="#ch18" class="nav-item">18. Recommendation API</a>
                <div class="child-nav">
                    <a href="#ch18-1" class="nav-item">User-Based Recommendations</a>
                    <a href="#ch18-2" class="nav-item">Item-Based Recommendations</a>
                    <a href="#ch18-3" class="nav-item">Real-time vs Batch</a>
                </div>
                <a href="#ch19" class="nav-item">19. Future Directions</a>
                <div class="child-nav">
                    <a href="#ch19-1" class="nav-item">Emerging AI Models</a>
                    <a href="#ch19-2" class="nav-item">AI Agents and APIs</a>
                    <a href="#ch19-3" class="nav-item">Ethical Considerations</a>
                </div>
                <a href="#ch20" class="nav-item">20. Conclusion</a>
            </div>

            <div class="nav-section">
                <div class="nav-section-title">Appendices</div>
                <a href="#appendix-a" class="nav-item">A. Pydantic Migration Guide</a>
                <a href="#appendix-b" class="nav-item">B. FastAPI Advanced Features</a>
                <a href="#appendix-c" class="nav-item">C. Configuration Patterns</a>
            </div>
        </div>
    </aside>

    <main class="main-content">
        <div id="introduction">
            <h1>Intelligent APIs: Serving AI Models Seamlessly with Pydantic and Python Frameworks</h1>

            <div class="card">
                <div class="card-title">About This Book</div>
                <p>
                    This comprehensive guide explores the art and science of building robust APIs for AI model
                    deployment using Python's modern frameworks and libraries, with a special focus on Pydantic for data
                    validation and schema definition.
                </p>
                <div class="flex flex-wrap">
                    <span class="pill"><i class="fas fa-code"></i> Python</span>
                    <span class="pill"><i class="fas fa-brain"></i> AI</span>
                    <span class="pill"><i class="fas fa-server"></i> APIs</span>
                    <span class="pill"><i class="fas fa-check-circle"></i> Validation</span>
                    <span class="pill"><i class="fas fa-bolt"></i> FastAPI</span>
                </div>
            </div>

            <div class="table-of-contents">
                <div class="toc-title">Table of Contents</div>
                <div class="toc-item"><a href="#preface">Preface</a></div>
                <div class="toc-item"><a href="#how-to-use-this-book">How to Use This Book</a></div>
                <div class="toc-item"><a href="#ch1">Chapter 1: The API-Driven AI Revolution</a></div>
                <div class="toc-item toc-level-2"><a href="#ch1-1">The Evolution of AI Deployment Methods</a></div>
                <div class="toc-item toc-level-2"><a href="#ch1-2">The Python Ecosystem for AI Model Serving</a></div>
                <div class="toc-item toc-level-2"><a href="#ch1-3">Introduction to Pydantic</a></div>
                <div class="toc-item"><a href="#ch2">Chapter 2: Pydantic Essentials for API Developers</a></div>
                <div class="toc-item toc-level-2"><a href="#ch2-1">Core Concepts</a></div>
                <div class="toc-item toc-level-2"><a href="#ch2-2">Field Customization</a></div>
                <div class="toc-item toc-level-2"><a href="#ch2-3">Nested Models & Complex Structures</a></div>
                <div class="toc-item toc-level-2"><a href="#ch2-4">Settings Management with Pydantic</a></div>
                <div class="toc-item"><a href="#ch3">Chapter 3: Designing Your AI API Contract with Pydantic</a></div>
                <div class="toc-item toc-level-2"><a href="#ch3-1">Principles of Good API Design for AI Services</a>
                </div>
                <div class="toc-item toc-level-2"><a href="#ch3-2">Modeling AI Inputs</a></div>
                <div class="toc-item toc-level-2"><a href="#ch3-3">Modeling AI Outputs</a></div>
                <div class="toc-item toc-level-2"><a href="#ch3-4">Best Practices for Clear and Maintainable API
                        Schemas</a></div>
                <!-- Dynamically add more TOC items as chapters are added -->
            </div>
        </div>

        <div id="preface">
            <h2>Preface <a href="#preface" class="header-anchor">#</a></h2>
            <p>
                Welcome to "Intelligent APIs: Serving AI Models Seamlessly with Pydantic and Python Frameworks." As we
                enter 2025, the landscape of artificial intelligence deployment has dramatically shifted. Gone are the
                days when AI models lived primarily in research papers or Jupyter notebooks. Today, AI capabilities are
                expected to be accessible, reliable, and scalable—and APIs are the bridge that makes this possible.
            </p>
            <p>
                This book was born from a simple observation: while many excellent resources teach you how to build AI
                models, significantly fewer address the critical challenge of how to properly serve those models to
                applications, users, and systems that need them. Creating a robust API layer for AI functionality
                requires specialized knowledge that bridges machine learning expertise with software engineering best
                practices.
            </p>
            <p>
                Throughout my career working with companies from startups to enterprises, I've witnessed firsthand the
                challenges teams face when moving AI from experimentation to production. A common pattern emerged:
                engineers would build impressive models but struggle with the seemingly mundane task of creating stable,
                well-documented, and maintainable APIs to make those models accessible.
            </p>
            <p>
                Python has emerged as the dominant language for AI development, and its ecosystem has responded with
                powerful tools for API development. At the center of modern Python API development is Pydantic—a
                game-changing library that brings structure, validation, and clarity to data flowing in and out of your
                systems. Combined with frameworks like FastAPI, it enables developers to build production-ready,
                performant, and well-documented APIs with significantly less effort than was previously possible.
            </p>
            <p>
                This book is designed to be both practical and comprehensive. We'll progress from foundational concepts
                to advanced deployment strategies, all through the lens of real-world AI applications. Each chapter
                builds upon the previous one, providing you with the knowledge and tools to create APIs that your users
                and fellow developers will appreciate.
            </p>
            <p>
                Whether you're a machine learning engineer looking to better serve your models, a backend developer
                tasked with integrating AI capabilities, or a technical leader guiding your team through the
                complexities of AI deployment, this book will provide you with concrete strategies, patterns, and code
                examples you can apply immediately.
            </p>
            <p>
                Thank you for joining me on this journey. Let's build the next generation of intelligent APIs together.
            </p>
        </div>

        <div id="how-to-use-this-book">
            <h2>How to Use This Book <a href="#how-to-use-this-book" class="header-anchor">#</a></h2>
            <p>
                This book is designed to serve a wide range of readers, from those just starting with API development to
                experienced engineers looking to optimize their AI deployment strategies. Here's how to get the most
                from these pages:
            </p>

            <div class="card">
                <div class="card-title">Book Structure</div>
                <p>The content is organized into five parts:</p>
                <ol>
                    <li><strong>Foundations of Intelligent APIs</strong>: Core concepts and tools (Chapters 1-3)</li>
                    <li><strong>Building Intelligent APIs</strong>: Framework choices and implementation (Chapters 4-7)
                    </li>
                    <li><strong>Advanced Implementation</strong>: Optimizing performance and reliability (Chapters 8-11)
                    </li>
                    <li><strong>Testing, Documentation, and Deployment</strong>: Ensuring quality and availability
                        (Chapters 12-15)</li>
                    <li><strong>Case Studies and Future Directions</strong>: Real-world examples and emerging trends
                        (Chapters 16-20)</li>
                </ol>
            </div>

            <h3>Prerequisites</h3>
            <p>
                This book assumes basic familiarity with:
            </p>
            <ul>
                <li>Python programming language (version 3.8+)</li>
                <li>RESTful API concepts and HTTP methods</li>
                <li>Basic understanding of AI/ML concepts (though we'll explain model-specific details)</li>
            </ul>

            <h3>Code Examples</h3>
            <p>
                All code examples are available in the book and can be copied directly for your own projects. Examples
                use Python 3.10+ and the latest versions of libraries as of 2025. The examples are designed to be
                practical rather than theoretical—you can adapt them directly to your own projects.
            </p>

            <div class="note">
                <p><strong>Note:</strong> Throughout the book, you'll find these highlighted note sections that contain
                    important tips, warnings, or additional context to help you avoid common pitfalls.</p>
            </div>

            <h3>Reading Approaches</h3>
            <p>Depending on your needs and experience level, consider these reading strategies:</p>
            <ul>
                <li><strong>Sequential Reading</strong>: If you're new to API development or Pydantic, reading from
                    start to finish provides a logical progression of concepts.</li>
                <li><strong>Topic-Focused</strong>: For experienced developers, you may want to jump to specific
                    chapters addressing your current challenges (e.g., Chapter 10 for performance, Chapter 15 for
                    deployment).</li>
                <li><strong>Case Study Learning</strong>: If you learn best from examples, start with the case studies
                    in Part V (Chapters 16-18), then refer back to earlier chapters for the underlying concepts.</li>
            </ul>

            <div class="warning">
                <p><strong>Important:</strong> The AI field moves quickly. While the principles in this book will remain
                    relevant, specific library versions and features may evolve. Always check the official documentation
                    for the latest API changes.</p>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- PART I: FOUNDATIONS OF INTELLIGENT APIs -->
        <div id="part1" class="mb-6">
            <h1>Part I: Foundations of Intelligent APIs</h1>
            <p>This part lays the groundwork for understanding AI APIs, the Python ecosystem, and the crucial role of
                Pydantic.</p>
        </div>

        <!-- CHAPTER 1 -->
        <div id="ch1">
            <h2>Chapter 1: The API-Driven AI Revolution <a href="#ch1" class="header-anchor">#</a></h2>
            <p>
                The journey from creating AI models to deploying them in production has undergone a revolutionary
                transformation. This chapter explores how APIs have become the standard interface for AI capabilities
                and why modern Python tools are crucial to this paradigm.
            </p>

            <div id="ch1-1">
                <h3>1.1 The Evolution of AI Deployment Methods <a href="#ch1-1" class="header-anchor">#</a></h3>
                <p>
                    Artificial intelligence deployment has progressed through several distinct phases, each addressing
                    limitations of previous approaches:
                </p>
                <h4>1.1.1 The Notebook Era</h4>
                <p>Placeholder content discussing the limitations of deploying models directly from notebooks
                    (scalability, environment issues, lack of standard interface).</p>
                <h4>1.1.2 The Monolithic Application Approach</h4>
                <p>Placeholder content explaining the practice of embedding models directly into applications and its
                    drawbacks (tight coupling, difficult updates, resource contention).</p>
                <h4>1.1.3 The API Revolution</h4>
                <p>Placeholder content detailing the shift towards serving models via APIs, separating concerns, and
                    enabling independent scaling and development cycles.</p>
                <div class="card">
                    <div class="card-title">Benefits of API-Driven AI</div>
                    <p>Placeholder list of benefits like language agnosticism, independent scaling, versioning,
                        monitoring, and security.</p>
                </div>
            </div>

            <div id="ch1-2">
                <h3>1.2 The Python Ecosystem for AI Model Serving <a href="#ch1-2" class="header-anchor">#</a></h3>
                <p>
                    Python has firmly established itself as the dominant language for AI development, and its ecosystem
                    has evolved to support the entire AI lifecycle, including deployment. Let's explore the key
                    components that make Python ideal for serving AI models via APIs.
                </p>
                <h4>1.2.1 Web Frameworks for AI APIs</h4>
                <p>Placeholder content introducing popular Python web frameworks suitable for AI APIs.</p>
                <div class="card">
                    <div class="card-title">FastAPI</div>
                    <p>Placeholder highlighting FastAPI's speed, type hints, auto-docs, async support, and dependency
                        injection, making it a prime choice.</p>
                </div>
                <h4>1.2.2 Other Popular Frameworks</h4>
                <p>Placeholder content mentioning Flask, Django DRF, Starlette, and specialized ML servers like
                    TensorFlow Serving, discussing their pros and cons for AI APIs.</p>
                <h4>1.2.3 ASGI vs WSGI: Understanding the Performance Implications</h4>
                <p>Placeholder content explaining the difference between synchronous WSGI and asynchronous ASGI, and why
                    ASGI is often preferred for I/O-bound or high-concurrency AI tasks.</p>
                <h4>1.2.4 Deployment and Scaling Tools</h4>
                <p>Placeholder content listing essential tools like Docker, Kubernetes, Uvicorn/Gunicorn, Nginx, and
                    monitoring stacks (Prometheus/Grafana).</p>
            </div>

            <div id="ch1-3">
                <h3>1.3 Introduction to Pydantic: The Foundation of Modern Python APIs <a href="#ch1-3"
                        class="header-anchor">#</a></h3>
                <p>
                    At the heart of modern Python API development is Pydantic, a data validation and settings management
                    library that uses Python type annotations to enforce type and constraint checking at runtime.
                </p>
                <h4>1.3.1 Why Pydantic Matters for AI APIs</h4>
                <p>Placeholder content explaining Pydantic's benefits: input validation, structured data conversion,
                    schema documentation, error handling, and type safety.</p>
                <h4>1.3.2 Basic Pydantic Concepts</h4>
                <p>Placeholder content introducing BaseModel, field definitions with type hints, basic validation, and
                    serialization/deserialization.</p>
                <div class="code-sample">
                    <span class="language-badge">Basic Pydantic Model</span>
                    <pre><code class="language-python"># Placeholder for basic Pydantic model example
from pydantic import BaseModel

class BasicRequest(BaseModel):
    query: str
    limit: int = 10</code></pre>
                </div>
                <h4>1.3.3 Pydantic and FastAPI: A Perfect Match</h4>
                <p>Placeholder content describing the seamless integration: automatic request/response validation and
                    OpenAPI documentation generation.</p>
                <h4>1.3.4 Pydantic v2 and Beyond</h4>
                <p>Placeholder content mentioning the performance improvements and API changes in Pydantic v2 (Rust
                    core, new methods like model_dump).</p>
            </div>

            <h3>1.4 Chapter Summary</h3>
            <p>Placeholder summarizing the key takeaways: the rise of APIs for AI, the relevant Python ecosystem, and
                the central role of Pydantic.</p>

            <div class="chapter-nav">
                <span></span>
                <a href="#ch2" class="chapter-nav-btn">Next: Chapter 2 - Pydantic Essentials <i
                        class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 2 -->
        <div id="ch2">
            <h2>Chapter 2: Pydantic Essentials for API Developers <a href="#ch2" class="header-anchor">#</a></h2>
            <p>
                Pydantic has revolutionized how Python developers handle data validation and parsing. In this chapter,
                we'll explore Pydantic's core features and demonstrate how they address the specific needs of AI API
                development.
            </p>

            <div id="ch2-1">
                <h3>2.1 Core Concepts: Models, Fields, and Validation <a href="#ch2-1" class="header-anchor">#</a></h3>
                <p>
                    To build effective AI APIs, we need to understand Pydantic's fundamental building blocks and how
                    they work together to ensure data integrity.
                </p>
                <h4>2.1.1 BaseModel: The Foundation</h4>
                <p>Placeholder content diving deeper into BaseModel inheritance and instantiation.</p>
                <h4>2.1.2 Field Types and Annotations</h4>
                <p>Placeholder content providing more examples of common and advanced field types (str, int, float,
                    List, Dict, Optional, Union, Literal, datetime, Url types, etc.).</p>
                <h4>2.1.3 Basic Validation with Field()</h4>
                <p>Placeholder content demonstrating various constraints using `Field()` (min/max length, numeric
                    ranges, regex patterns).</p>
                <div class="code-sample">
                    <span class="language-badge">Field() Constraints Example</span>
                    <pre><code class="language-python"># Placeholder for Field() constraints example
from pydantic import BaseModel, Field

class ConstrainedRequest(BaseModel):
    text: str = Field(..., min_length=10, max_length=1000)
    threshold: float = Field(..., ge=0.0, le=1.0)</code></pre>
                </div>
                <h4>2.1.4 Custom Validation with Validators</h4>
                <p>Placeholder content explaining how to use `@validator` for single-field, multi-field, and dependent
                    field validation logic.</p>
            </div>

            <div id="ch2-2">
                <h3>2.2 Field Customization <a href="#ch2-2" class="header-anchor">#</a></h3>
                <p>
                    Beyond basic validation, Pydantic offers various ways to customize how fields are processed, named,
                    and documented.
                </p>
                <h4>2.2.1 Field Aliases</h4>
                <p>Placeholder content explaining how to use `alias` in `Field()` for different external vs. internal
                    naming conventions (e.g., camelCase vs. snake_case).</p>
                <h4>2.2.2 Default Values and Optional Fields</h4>
                <p>Placeholder content detailing `Optional[T]`, default values, and `default_factory` for mutable
                    defaults like lists or dicts.</p>
                <h4>2.2.3 Documentation-Friendly Fields</h4>
                <p>Placeholder content showing how to use `description`, `examples`, and `title` within `Field()` and
                    `Config` for better auto-generated documentation.</p>
            </div>

            <div id="ch2-3">
                <h3>2.3 Nested Models and Complex Structures <a href="#ch2-3" class="header-anchor">#</a></h3>
                <p>
                    AI APIs often deal with complex, hierarchical data structures. Pydantic excels at modeling these
                    relationships through nested models.
                </p>
                <h4>2.3.1 Composing Models Through Nesting</h4>
                <p>Placeholder content demonstrating how to nest BaseModel instances within other models for structured
                    data.</p>
                <div class="code-sample">
                    <span class="language-badge">Nested Model Example</span>
                    <pre><code class="language-python"># Placeholder for nested model example
from pydantic import BaseModel
from typing import List

class Item(BaseModel):
    name: str
    price: float

class Order(BaseModel):
    order_id: int
    items: List[Item]</code></pre>
                </div>
                <h4>2.3.2 Working with Lists and Dictionaries</h4>
                <p>Placeholder content showing validation of collection types like `List[Model]` or `Dict[str, Model]`.
                </p>
                <h4>2.3.3 Dynamic Field Names with Dict Pattern Models</h4>
                <p>Placeholder content explaining how to handle models where field names are not known in advance,
                    possibly using `__root__` or `Config.extra = 'allow'`.</p>
                <h4>2.3.4 Generic Models for Reusable Patterns</h4>
                <p>Placeholder content introducing Pydantic's support for `typing.Generic` to create reusable model
                    structures like standard API responses.</p>
            </div>

            <div id="ch2-4">
                <h3>2.4 Settings Management with Pydantic <a href="#ch2-4" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how to use `pydantic-settings` (`BaseSettings`) for loading
                    application configuration from environment variables or .env files, ensuring type safety for
                    settings.</p>
                <div class="code-sample">
                    <span class="language-badge">Settings Management Example</span>
                    <pre><code class="language-python"># Placeholder for pydantic-settings example
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    api_key: str
    model_name: str = "default-model"
    debug: bool = False

    class Config:
        env_file = '.env'

settings = Settings()</code></pre>
                </div>
            </div>

            <h3>2.5 Chapter Summary</h3>
            <p>Placeholder summarizing Pydantic's core features: models, fields, validation (built-in and custom),
                customization (aliases, defaults), complex structures (nesting, generics), and settings management.</p>

            <div class="chapter-nav">
                <a href="#ch1" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 1</a>
                <a href="#ch3" class="chapter-nav-btn">Next: Chapter 3 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 3 -->
        <div id="ch3">
            <h2>Chapter 3: Designing Your AI API Contract with Pydantic <a href="#ch3" class="header-anchor">#</a></h2>
            <p>
                API design is a critical aspect of AI model deployment. A well-designed API contract makes your models
                more accessible, understandable, and maintainable. In this chapter, we'll explore how to use Pydantic to
                create clear, consistent, and user-friendly API contracts specifically for AI services.
            </p>

            <div id="ch3-1">
                <h3>3.1 Principles of Good API Design for AI Services <a href="#ch3-1" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing core API design principles tailored for AI: clarity, predictability,
                    robust validation, versioning, performance considerations, and security/privacy.</p>
                <h4>3.1.1 Clarity and Predictability</h4>
                <p>Placeholder: Use descriptive names, consistent conventions, enums/literals, sensible defaults.</p>
                <h4>3.1.2 Input Validation and Error Handling</h4>
                <p>Placeholder: Validate early, provide informative errors, use domain-specific rules.</p>
                <h4>3.1.3 Versioning and Compatibility</h4>
                <p>Placeholder: Plan for versions, design extensible schemas, handle backward compatibility.</p>
                <h4>3.1.4 Performance Considerations</h4>
                <p>Placeholder: Batching, async processing, caching, performance metadata.</p>
                <h4>3.1.5 Security and Privacy</h4>
                <p>Placeholder: Input/output sanitization, privacy implications, access control, auditability.</p>
                <div class="card">
                    <div class="card-title">REST Resource Modeling for AI Endpoints</div>
                    <p>Placeholder table showing examples of how different AI tasks (classification, generation, etc.)
                        map to REST resources and methods.</p>
                </div>
            </div>

            <div id="ch3-2">
                <h3>3.2 Modeling AI Inputs: Text, Numerical Data, and Multimodal Inputs <a href="#ch3-2"
                        class="header-anchor">#</a></h3>
                <p>
                    Different AI models require different types of inputs. Let's explore how to model various input
                    types using Pydantic.
                </p>
                <h4>3.2.1 Text Input Models</h4>
                <p>Placeholder content showing Pydantic models for NLP tasks (classification, generation) with relevant
                    fields (text, language, max_tokens, temperature).</p>
                <h4>3.2.2 Numerical and Structured Data Inputs</h4>
                <p>Placeholder content demonstrating models for time series or tabular data, validating feature types
                    and constraints.</p>
                <h4>3.2.3 Image and Multimodal Inputs</h4>
                <p>Placeholder content illustrating how to model image inputs (URL vs. base64) and combine multiple
                    modalities (text, image, audio).</p>
                <h4>3.2.4 Batch Processing Inputs</h4>
                <p>Placeholder content designing schemas for batch requests, including item lists and batch-level
                    parameters.</p>
            </div>

            <div id="ch3-3">
                <h3>3.3 Modeling AI Outputs: Predictions, Probabilities, and Explanations <a href="#ch3-3"
                        class="header-anchor">#</a></h3>
                <p>
                    Defining clear, consistent output structures is just as important as validating inputs. Let's
                    explore how to model different types of AI model outputs.
                </p>
                <h4>3.3.1 Classification and Prediction Outputs</h4>
                <p>Placeholder content showing models for classification results (label, confidence) and alternatives.
                </p>
                <h4>3.3.2 Regression and Numerical Outputs</h4>
                <p>Placeholder content demonstrating models for regression (predicted value, confidence intervals).</p>
                <h4>3.3.3 Natural Language Generation Outputs</h4>
                <p>Placeholder content illustrating models for text generation outputs (generated text, token counts,
                    finish reason).</p>
                <h4>3.3.4 Image Analysis Outputs</h4>
                <p>Placeholder content showing models for computer vision results (bounding boxes, detected objects,
                    masks).</p>
                <h4>3.3.5 Model Explanations and Interpretability</h4>
                <p>Placeholder content designing schemas for explainable AI (XAI) outputs (feature importance, evidence
                    highlighting).</p>
                <h4>3.3.6 Error and Status Responses</h4>
                <p>Placeholder content defining standardized error response models, including validation errors.</p>
                <h4>3.3.7 Generic Response Wrappers</h4>
                <p>Placeholder content promoting consistent API responses using generic wrappers containing status,
                    data/error, metadata (request ID, timing, versions).</p>
            </div>

            <div id="ch3-4">
                <h3>3.4 Best Practices for Clear and Maintainable API Schemas <a href="#ch3-4"
                        class="header-anchor">#</a></h3>
                <p>Placeholder content summarizing best practices learned throughout the chapter.</p>
                <h4>3.4.1 Schema Organization Patterns</h4>
                <p>Placeholder: Modular models, consistent naming, grouping, separation of concerns.</p>
                <h4>3.4.2 Documentation Enhancements</h4>
                <p>Placeholder: Use descriptions, examples, titles effectively.</p>
                <h4>3.4.3 Versioning and Evolution</h4>
                <p>Placeholder: Add optional fields, use version identifiers, manage deprecation.</p>
                <h4>3.4.4 Testing and Validation</h4>
                <p>Placeholder: Unit test schemas, test edge cases, ensure serialization works.</p>
            </div>

            <h3>3.5 Chapter Summary</h3>
            <p>Placeholder summarizing the design principles and Pydantic modeling techniques for AI API inputs and
                outputs, emphasizing clarity and maintainability.</p>

            <div class="chapter-nav">
                <a href="#ch2" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 2</a>
                <a href="#ch4" class="chapter-nav-btn">Next: Chapter 4 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- PART II: BUILDING APIs -->
        <div id="part2" class="mb-6">
            <h1>Part II: Building Intelligent APIs</h1>
            <p>This part focuses on implementing the APIs using specific Python frameworks, with a deep dive into
                FastAPI and alternatives.</p>
        </div>

        <!-- CHAPTER 4 -->
        <div id="ch4">
            <h2>Chapter 4: Building with FastAPI <a href="#ch4" class="header-anchor">#</a></h2>
            <p>FastAPI has emerged as a leading framework for building modern Python APIs, especially those serving AI
                models. This chapter covers the essentials of using FastAPI effectively with Pydantic for robust AI
                services.</p>

            <div id="ch4-1">
                <h3>4.1 Why FastAPI for AI APIs? <a href="#ch4-1" class="header-anchor">#</a></h3>
                <p>Placeholder content reinforcing the benefits: performance (ASGI), Pydantic integration, automatic
                    docs, async support, dependency injection.</p>
            </div>

            <div id="ch4-2">
                <h3>4.2 Request Handling <a href="#ch4-2" class="header-anchor">#</a></h3>
                <p>Placeholder content showing how to define API routes (`@app.post`, `@app.get`), handle path
                    parameters, query parameters, and request bodies using Pydantic models.</p>
                <div class="code-sample">
                    <span class="language-badge">FastAPI Request Handling</span>
                    <pre><code class="language-python"># Placeholder for FastAPI request handling
from fastapi import FastAPI
from pydantic import BaseModel

app = FastAPI()

class Item(BaseModel):
    name: str
    description: str | None = None

@app.post("/items/")
async def create_item(item: Item):
    # item is automatically validated Pydantic model
    return {"item_name": item.name, "status": "created"}

@app.get("/items/{item_id}")
async def read_item(item_id: int, q: str | None = None):
    return {"item_id": item_id, "q": q}</code></pre>
                </div>
            </div>

            <div id="ch4-3">
                <h3>4.3 Response Modeling <a href="#ch4-3" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how to use the `response_model` parameter in route decorators to
                    automatically serialize and validate response data using Pydantic models, ensuring the API contract
                    is met.</p>
            </div>

            <div id="ch4-4">
                <h3>4.4 Async and Concurrency <a href="#ch4-4" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing how to leverage `async def` for endpoint functions, handle I/O-bound
                    tasks concurrently, and integrate potentially blocking AI inference calls safely (e.g., using
                    `run_in_threadpool`).</p>
            </div>

            <div id="ch4-5">
                <h3>4.5 Dependency Injection <a href="#ch4-5" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining FastAPI's powerful dependency injection system for managing shared
                    resources like database connections, settings objects, or loaded AI models.</p>
                <div class="code-sample">
                    <span class="language-badge">FastAPI Dependency Injection</span>
                    <pre><code class="language-python"># Placeholder for FastAPI dependency injection
from fastapi import Depends, FastAPI

app = FastAPI()

# Example dependency (e.g., loading a model or settings)
def get_model():
    print("Loading model...")
    # In reality, load and return your model instance
    return {"model_type": "sentiment"} 

@app.post("/predict/")
async def predict(data: dict, model: dict = Depends(get_model)):
    # model is injected by FastAPI
    print(f"Using model: {model}")
    return {"prediction": "positive"}</code></pre>
                </div>
            </div>

            <h3>4.6 Chapter Summary</h3>
            <p>Placeholder summarizing how to build AI APIs with FastAPI, leveraging its core features like routing,
                Pydantic integration, async handling, and dependency injection.</p>

            <div class="chapter-nav">
                <a href="#ch3" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 3</a>
                <a href="#ch5" class="chapter-nav-btn">Next: Chapter 5 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 5 -->
        <div id="ch5">
            <h2>Chapter 5: Alternative Frameworks <a href="#ch5" class="header-anchor">#</a></h2>
            <p>While FastAPI is excellent, other Python frameworks can also be used effectively with Pydantic to build
                AI APIs. This chapter explores popular alternatives and how they compare.</p>

            <div id="ch5-1">
                <h3>5.1 Flask + Pydantic <a href="#ch5-1" class="header-anchor">#</a></h3>
                <p>Placeholder content demonstrating how to integrate Pydantic for validation within a Flask
                    application, often using extensions like `Flask-Pydantic`.</p>
            </div>

            <div id="ch5-2">
                <h3>5.2 Django DRF + Pydantic <a href="#ch5-2" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how Pydantic can complement or replace Django REST Framework's
                    serializers for data validation, especially in complex scenarios.</p>
            </div>

            <div id="ch5-3">
                <h3>5.3 Starlette Basics <a href="#ch5-3" class="header-anchor">#</a></h3>
                <p>Placeholder content showing how to use Starlette (the ASGI toolkit underlying FastAPI) directly for
                    maximum performance and control, integrating Pydantic manually.</p>
            </div>

            <div id="ch5-4">
                <h3>5.4 Specialized ML Serving Frameworks <a href="#ch5-4" class="header-anchor">#</a></h3>
                <p>Placeholder content briefly discussing frameworks like TorchServe, TensorFlow Serving, or Ray Serve,
                    highlighting their focus on model serving efficiency but potential limitations in API flexibility
                    compared to general web frameworks.</p>
            </div>

            <h3>5.5 Chapter Summary</h3>
            <p>Placeholder summarizing the use of Pydantic with alternative frameworks like Flask and Django DRF, and
                comparing them to FastAPI and specialized ML servers.</p>

            <div class="chapter-nav">
                <a href="#ch4" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 4</a>
                <a href="#ch6" class="chapter-nav-btn">Next: Chapter 6 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 6 -->
        <div id="ch6">
            <h2>Chapter 6: Advanced Validation Techniques <a href="#ch6" class="header-anchor">#</a></h2>
            <p>Go beyond basic constraints with Pydantic's advanced validation features to enforce complex business
                logic and ensure data integrity for your AI models.</p>

            <div id="ch6-1">
                <h3>6.1 Advanced Custom Validators <a href="#ch6-1" class="header-anchor">#</a></h3>
                <p>Placeholder content exploring more complex `@validator` scenarios, including pre-validation,
                    always-run validators, and reusing validators.</p>
            </div>

            <div id="ch6-2">
                <h3>6.2 Root Validators for Cross-Field Validation <a href="#ch6-2" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how to use `@root_validator` to validate relationships between
                    multiple fields within a model.</p>
                <div class="code-sample">
                    <span class="language-badge">Root Validator Example</span>
                    <pre><code class="language-python"># Placeholder for root validator example
from pydantic import BaseModel, root_validator

class DateRange(BaseModel):
    start_date: date
    end_date: date

    @root_validator
    def check_dates(cls, values):
        start, end = values.get('start_date'), values.get('end_date')
        if start and end and start > end:
            raise ValueError("start_date cannot be after end_date")
        return values</code></pre>
                </div>
            </div>

            <div id="ch6-3">
                <h3>6.3 Constrained Types <a href="#ch6-3" class="header-anchor">#</a></h3>
                <p>Placeholder content introducing Pydantic's built-in constrained types (e.g., `constr`, `conint`,
                    `confloat`) for reusable validation patterns.</p>
            </div>

            <div id="ch6-4">
                <h3>6.4 Validation Performance Considerations <a href="#ch6-4" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing the performance implications of complex validation, especially in
                    Pydantic v2 with its Rust core, and strategies for optimization.</p>
            </div>

            <h3>6.5 Chapter Summary</h3>
            <p>Placeholder summarizing advanced Pydantic validation techniques, including custom validators, root
                validators, constrained types, and performance considerations.</p>

            <div class="chapter-nav">
                <a href="#ch5" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 5</a>
                <a href="#ch7" class="chapter-nav-btn">Next: Chapter 7 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 7 -->
        <div id="ch7">
            <h2>Chapter 7: Security and Authentication <a href="#ch7" class="header-anchor">#</a></h2>
            <p>Securing your AI API is paramount, especially when dealing with potentially sensitive data or controlling
                access to expensive computational resources. This chapter covers common security patterns.</p>

            <div id="ch7-1">
                <h3>7.1 API Key Authentication <a href="#ch7-1" class="header-anchor">#</a></h3>
                <p>Placeholder content demonstrating how to implement simple API key authentication using headers or
                    query parameters, suitable for machine-to-machine communication.</p>
            </div>

            <div id="ch7-2">
                <h3>7.2 OAuth2 and JWT for User Authentication <a href="#ch7-2" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how to integrate standard authentication flows like OAuth2 Password
                    Flow or use JSON Web Tokens (JWT) for securing endpoints accessed by users.</p>
                <div class="note">
                    <p>Placeholder note on using FastAPI's built-in security utilities (`Security` function,
                        `HTTPBearer`, `OAuth2PasswordBearer`).</p>
                </div>
            </div>

            <div id="ch7-3">
                <h3>7.3 Input Sanitization and Validation <a href="#ch7-3" class="header-anchor">#</a></h3>
                <p>Placeholder content reinforcing the role of Pydantic validation as a first line of defense against
                    malformed or malicious inputs. Discussing potential need for further sanitization depending on the
                    model.</p>
            </div>

            <div id="ch7-4">
                <h3>7.4 Rate Limiting Strategies <a href="#ch7-4" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing the importance of rate limiting to prevent abuse and ensure fair
                    usage, exploring implementation options (e.g., using middleware, external services like Redis).</p>
            </div>

            <h3>7.5 Chapter Summary</h3>
            <p>Placeholder summarizing key security measures for AI APIs: authentication (API keys, OAuth2/JWT), input
                validation/sanitization, and rate limiting.</p>

            <div class="chapter-nav">
                <a href="#ch6" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 6</a>
                <a href="#ch8" class="chapter-nav-btn">Next: Chapter 8 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- PART III: ADVANCED IMPLEMENTATION -->
        <div id="part3" class="mb-6">
            <h1>Part III: Advanced Implementation</h1>
            <p>Dive deeper into the practical aspects of integrating models, optimizing performance, and ensuring
                robustness.</p>
        </div>

        <!-- CHAPTER 8 -->
        <div id="ch8">
            <h2>Chapter 8: Integrating AI Model Inference <a href="#ch8" class="header-anchor">#</a></h2>
            <p>Bridging the gap between your API framework and the actual AI model execution requires careful
                consideration of loading, execution, and resource management.</p>

            <div id="ch8-1">
                <h3>8.1 Loading Models Efficiently <a href="#ch8-1" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing strategies for loading models: at startup vs. on-demand, lazy loading,
                    using dependency injection to manage model instances.</p>
            </div>

            <div id="ch8-2">
                <h3>8.2 Synchronous vs. Asynchronous Inference <a href="#ch8-2" class="header-anchor">#</a></h3>
                <p>Placeholder content analyzing the challenges of integrating potentially long-running, blocking model
                    inference calls within an async (ASGI) framework like FastAPI. Discussing techniques like
                    `run_in_threadpool`.</p>
            </div>

            <div id="ch8-3">
                <h3>8.3 Handling GPU Resources <a href="#ch8-3" class="header-anchor">#</a></h3>
                <p>Placeholder content addressing the complexities of managing GPU memory and compute, especially in
                    multi-worker or concurrent request scenarios.</p>
                <div class="warning">
                    <p>Placeholder warning about GIL limitations and GPU resource contention.</p>
                </div>
            </div>

            <div id="ch8-4">
                <h3>8.4 Background Tasks for Long-Running Jobs <a href="#ch8-4" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how to use background tasks (e.g., FastAPI's `BackgroundTasks`,
                    Celery) for inference jobs that exceed typical request timeouts, returning job IDs and status
                    endpoints.</p>
            </div>

            <h3>8.5 Chapter Summary</h3>
            <p>Placeholder summarizing strategies for integrating AI model inference into APIs, focusing on loading,
                execution models (sync/async), resource management (GPU), and handling long-running tasks.</p>

            <div class="chapter-nav">
                <a href="#ch7" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 7</a>
                <a href="#ch9" class="chapter-nav-btn">Next: Chapter 9 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 9 -->
        <div id="ch9">
            <h2>Chapter 9: Serialization Strategies <a href="#ch9" class="header-anchor">#</a></h2>
            <p>Efficiently converting data between Python objects and API formats (like JSON) is crucial for performance
                and correctness. This chapter explores Pydantic's serialization capabilities.</p>

            <div id="ch9-1">
                <h3>9.1 Pydantic Serialization Control (model_dump) <a href="#ch9-1" class="header-anchor">#</a></h3>
                <p>Placeholder content diving into Pydantic v2's `model_dump()` method and its options (`mode`,
                    `by_alias`, `exclude`, `include`) for fine-grained control over serialization.</p>
            </div>

            <div id="ch9-2">
                <h3>9.2 Custom Encoders and Decoders <a href="#ch9-2" class="header-anchor">#</a></h3>
                <p>Placeholder content demonstrating how to define custom JSON encoders/decoders within Pydantic models
                    or FastAPI for handling non-standard data types (e.g., NumPy arrays, custom objects).</p>
            </div>

            <div id="ch9-3">
                <h3>9.3 Working with Binary Data <a href="#ch9-3" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing strategies for handling binary data (like images or audio) in API
                    requests/responses, including base64 encoding vs. file uploads.</p>
            </div>

            <div id="ch9-4">
                <h3>9.4 Performance Considerations <a href="#ch9-4" class="header-anchor">#</a></h3>
                <p>Placeholder content analyzing the performance impact of serialization, especially for large or
                    complex objects, and mentioning alternatives like msgpack or protobuf if needed.</p>
            </div>

            <h3>9.5 Chapter Summary</h3>
            <p>Placeholder summarizing Pydantic's serialization features, techniques for custom encoding/decoding,
                handling binary data, and performance implications.</p>

            <div class="chapter-nav">
                <a href="#ch8" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 8</a>
                <a href="#ch10" class="chapter-nav-btn">Next: Chapter 10 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 10 -->
        <div id="ch10">
            <h2>Chapter 10: Caching and Performance Optimization <a href="#ch10" class="header-anchor">#</a></h2>
            <p>Improve the responsiveness and efficiency of your AI API through effective caching and performance tuning
                techniques.</p>

            <div id="ch10-1">
                <h3>10.1 API-Level Caching Strategies <a href="#ch10-1" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing HTTP caching headers (`Cache-Control`, `ETag`) and implementing
                    server-side caching (e.g., in-memory, Redis) for frequent requests with identical inputs.</p>
            </div>

            <div id="ch10-2">
                <h3>10.2 Model-Level Caching <a href="#ch10-2" class="header-anchor">#</a></h3>
                <p>Placeholder content exploring caching intermediate results within the model inference pipeline or
                    caching the final model predictions based on specific input features.</p>
            </div>

            <div id="ch10-3">
                <h3>10.3 Profiling and Optimization <a href="#ch10-3" class="header-anchor">#</a></h3>
                <p>Placeholder content introducing tools and techniques for profiling Python code (cProfile,
                    line_profiler) and identifying bottlenecks in the API request lifecycle or model inference.</p>
            </div>

            <div id="ch10-4">
                <h3>10.4 Load Balancing and Scaling Workers <a href="#ch10-4" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing how load balancers distribute traffic across multiple API server
                    instances (workers) and how to configure worker counts (e.g., Gunicorn workers) for optimal
                    throughput.</p>
            </div>

            <h3>10.5 Chapter Summary</h3>
            <p>Placeholder summarizing performance optimization techniques: API and model caching, profiling, and
                scaling strategies like load balancing.</p>

            <div class="chapter-nav">
                <a href="#ch9" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 9</a>
                <a href="#ch11" class="chapter-nav-btn">Next: Chapter 11 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 11 -->
        <div id="ch11">
            <h2>Chapter 11: Error Handling and Monitoring <a href="#ch11" class="header-anchor">#</a></h2>
            <p>Building robust AI APIs requires comprehensive error handling, effective logging, and continuous
                monitoring to ensure reliability and diagnose issues quickly.</p>

            <div id="ch11-1">
                <h3>11.1 Robust Error Handling <a href="#ch11-1" class="header-anchor">#</a></h3>
                <p>Placeholder content demonstrating how to implement custom exception handlers (e.g., in FastAPI) to
                    return consistent, informative error responses based on application-specific or Pydantic validation
                    errors.</p>
                <div class="code-sample">
                    <span class="language-badge">FastAPI Exception Handler</span>
                    <pre><code class="language-python"># Placeholder for FastAPI exception handler
from fastapi import FastAPI, Request, HTTPException
from fastapi.responses import JSONResponse
from pydantic import ValidationError

app = FastAPI()

class ModelInferenceError(Exception):
    def __init__(self, message: str):
        self.message = message

@app.exception_handler(ModelInferenceError)
async def inference_exception_handler(request: Request, exc: ModelInferenceError):
    return JSONResponse(
        status_code=503, # Service Unavailable
        content={"message": f"Model inference failed: {exc.message}"},
    )

@app.exception_handler(ValidationError)
async def validation_exception_handler(request: Request, exc: ValidationError):
     return JSONResponse(
        status_code=422, # Unprocessable Entity
        content={"detail": exc.errors()},
     )</code></pre>
                </div>
            </div>

            <div id="ch11-2">
                <h3>11.2 Logging Best Practices <a href="#ch11-2" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing structured logging, configuring Python's logging module, and what
                    information to log (request IDs, timings, errors, key decisions).</p>
            </div>

            <div id="ch11-3">
                <h3>11.3 API Monitoring Tools <a href="#ch11-3" class="header-anchor">#</a></h3>
                <p>Placeholder content introducing common monitoring stacks like Prometheus (for metrics) and Grafana
                    (for dashboards), and how to instrument your API to expose relevant metrics (request count, latency,
                    error rates).</p>
            </div>

            <div id="ch11-4">
                <h3>11.4 Alerting on Failures and Anomalies <a href="#ch11-4" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing setting up alerts based on monitored metrics (e.g., using
                    Alertmanager) or logged errors (e.g., using Elasticsearch/Kibana alerts) to proactively detect
                    problems.</p>
            </div>

            <h3>11.5 Chapter Summary</h3>
            <p>Placeholder summarizing best practices for error handling, logging, monitoring, and alerting to build
                reliable and observable AI APIs.</p>

            <div class="chapter-nav">
                <a href="#ch10" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 10</a>
                <a href="#ch12" class="chapter-nav-btn">Next: Chapter 12 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- PART IV: TESTING, DOCUMENTATION, AND DEPLOYMENT -->
        <div id="part4" class="mb-6">
            <h1>Part IV: Testing, Documentation, and Deployment</h1>
            <p>Ensure the quality, usability, and availability of your AI API through rigorous testing, clear
                documentation, and robust deployment strategies.</p>
        </div>

        <!-- CHAPTER 12 -->
        <div id="ch12">
            <h2>Chapter 12: Testing Your AI API <a href="#ch12" class="header-anchor">#</a></h2>
            <p>Testing is crucial for AI APIs, covering not just the API logic but also aspects of the model's behavior
                through the API interface.</p>

            <div id="ch12-1">
                <h3>12.1 Unit Testing Endpoints and Logic <a href="#ch12-1" class="header-anchor">#</a></h3>
                <p>Placeholder content demonstrating how to write unit tests for API endpoints (using tools like
                    FastAPI's `TestClient` or Flask's test client) and business logic components, mocking dependencies
                    like models.</p>
            </div>

            <div id="ch12-2">
                <h3>12.2 Integration Testing with Pydantic Schemas <a href="#ch12-2" class="header-anchor">#</a></h3>
                <p>Placeholder content showing how to write integration tests that verify the request/response flow,
                    including Pydantic validation for both inputs and outputs.</p>
                <div class="code-sample">
                    <span class="language-badge">FastAPI TestClient Example</span>
                    <pre><code class="language-python"># Placeholder for FastAPI TestClient example
from fastapi.testclient import TestClient
from main import app # Assuming your FastAPI app is in main.py

client = TestClient(app)

def test_predict_endpoint():
    response = client.post("/predict/", json={"text": "This is a test"})
    assert response.status_code == 200
    # Further assertions on response body structure/content
    # Possibly validate response against Pydantic output model
    assert "prediction" in response.json()</code></pre>
                </div>
            </div>

            <div id="ch12-3">
                <h3>12.3 Testing Model Behavior via the API <a href="#ch12-3" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing strategies for testing the integrated AI model's behavior through the
                    API, including checking for expected outputs on known inputs, consistency, and robustness to edge
                    cases.</p>
            </div>

            <div id="ch12-4">
                <h3>12.4 Performance and Load Testing <a href="#ch12-4" class="header-anchor">#</a></h3>
                <p>Placeholder content introducing tools (like Locust, k6) and methodologies for performance testing
                    your AI API under load to identify bottlenecks and ensure it meets performance requirements.</p>
            </div>

            <h3>12.5 Chapter Summary</h3>
            <p>Placeholder summarizing the different layers of testing required for AI APIs: unit, integration, model
                behavior, and performance testing.</p>

            <div class="chapter-nav">
                <a href="#ch11" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 11</a>
                <a href="#ch13" class="chapter-nav-btn">Next: Chapter 13 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 13 -->
        <div id="ch13">
            <h2>Chapter 13: API Documentation Best Practices <a href="#ch13" class="header-anchor">#</a></h2>
            <p>Clear, accurate, and accessible documentation is essential for API adoption and usability. Leverage
                framework features and best practices to document your AI API effectively.</p>

            <div id="ch13-1">
                <h3>13.1 Auto-generated Docs with OpenAPI/Swagger <a href="#ch13-1" class="header-anchor">#</a></h3>
                <p>Placeholder content highlighting how frameworks like FastAPI automatically generate OpenAPI
                    specifications from Pydantic models and route definitions, providing interactive Swagger UI and
                    ReDoc interfaces.</p>
            </div>

            <div id="ch13-2">
                <h3>13.2 Enhancing Auto-Generated Documentation <a href="#ch13-2" class="header-anchor">#</a></h3>
                <p>Placeholder content showing how to enrich the auto-generated documentation using Pydantic field
                    descriptions, examples, titles, and FastAPI route docstrings and tags.</p>
            </div>

            <div id="ch13-3">
                <h3>13.3 Providing Interactive Examples and Tutorials <a href="#ch13-3" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing the value of going beyond basic schema documentation by providing
                    runnable code examples (e.g., `curl`, Python client code) and tutorials for common use cases.</p>
            </div>

            <div id="ch13-4">
                <h3>13.4 Keeping Documentation Up-to-Date <a href="#ch13-4" class="header-anchor">#</a></h3>
                <p>Placeholder content emphasizing that documentation should be treated as code, kept in sync with API
                    changes, and potentially integrated into CI/CD pipelines to ensure accuracy.</p>
            </div>

            <h3>13.5 Chapter Summary</h3>
            <p>Placeholder summarizing best practices for API documentation, leveraging auto-generation features,
                enhancing them with context and examples, and maintaining accuracy.</p>

            <div class="chapter-nav">
                <a href="#ch12" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 12</a>
                <a href="#ch14" class="chapter-nav-btn">Next: Chapter 14 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 14 -->
        <div id="ch14">
            <h2>Chapter 14: Versioning and Maintenance Strategies <a href="#ch14" class="header-anchor">#</a></h2>
            <p>AI models and API requirements evolve. Implementing effective versioning and maintenance strategies is
                crucial for managing changes without disrupting users.</p>

            <div id="ch14-1">
                <h3>14.1 API Versioning Strategies <a href="#ch14-1" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing common API versioning approaches: URL path versioning (e.g.,
                    `/v1/predict`), query parameter versioning, and header versioning, along with their pros and cons.
                </p>
            </div>

            <div id="ch14-2">
                <h3>14.2 Managing Schema Evolution with Pydantic <a href="#ch14-2" class="header-anchor">#</a></h3>
                <p>Placeholder content revisiting how to design Pydantic models for backward compatibility (adding
                    optional fields) and potentially using different model versions for different API versions.</p>
            </div>

            <div id="ch14-3">
                <h3>14.3 Deprecation Policies and Communication <a href="#ch14-3" class="header-anchor">#</a></h3>
                <p>Placeholder content outlining how to handle the deprecation of endpoints or fields: marking them,
                    logging warnings, communicating timelines to users, and eventually removing them.</p>
            </div>

            <div id="ch14-4">
                <h3>14.4 CI/CD Pipelines for AI APIs <a href="#ch14-4" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing the components of a Continuous Integration/Continuous Deployment
                    pipeline for AI APIs: automated testing, building container images, and deploying updates safely
                    (e.g., blue/green deployments).</p>
            </div>

            <h3>14.5 Chapter Summary</h3>
            <p>Placeholder summarizing strategies for API versioning, managing schema changes, handling deprecation, and
                implementing CI/CD for smooth maintenance and evolution.</p>

            <div class="chapter-nav">
                <a href="#ch13" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 13</a>
                <a href="#ch15" class="chapter-nav-btn">Next: Chapter 15 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 15 -->
        <div id="ch15">
            <h2>Chapter 15: Deployment Architectures <a href="#ch15" class="header-anchor">#</a></h2>
            <p>Choose the right deployment architecture to meet the scalability, availability, and cost requirements of
                your AI API.</p>

            <div id="ch15-1">
                <h3>15.1 Containerization with Docker <a href="#ch15-1" class="header-anchor">#</a></h3>
                <p>Placeholder content explaining how to package your Python API application, dependencies, and
                    potentially the AI model into Docker containers for consistent environments.</p>
                <div class="code-sample">
                    <span class="language-badge">Dockerfile Example</span>
                    <pre><code class="language-dockerfile"># Placeholder Dockerfile for FastAPI app
FROM python:3.10-slim

WORKDIR /app

COPY requirements.txt requirements.txt
RUN pip install --no-cache-dir -r requirements.txt

COPY . .

# Add model loading steps if needed
# COPY models/ /app/models/

EXPOSE 80

CMD ["uvicorn", "main:app", "--host", "0.0.0.0", "--port", "80"]</code></pre>
                </div>
            </div>

            <div id="ch15-2">
                <h3>15.2 Orchestration with Kubernetes <a href="#ch15-2" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing how Kubernetes can manage containerized AI APIs, handling scaling,
                    rolling updates, service discovery, and resource allocation (including GPUs).</p>
            </div>

            <div id="ch15-3">
                <h3>15.3 Serverless Deployment Options <a href="#ch15-3" class="header-anchor">#</a></h3>
                <p>Placeholder content exploring serverless platforms (like AWS Lambda, Google Cloud Functions, Azure
                    Functions) for deploying AI APIs, considering their pros (auto-scaling, pay-per-use) and cons (cold
                    starts, resource limits).</p>
            </div>

            <div id="ch15-4">
                <h3>15.4 Cloud Provider AI Platforms and Services <a href="#ch15-4" class="header-anchor">#</a></h3>
                <p>Placeholder content briefly mentioning managed AI platforms (like SageMaker, Vertex AI, Azure ML)
                    that offer integrated model deployment and hosting capabilities, comparing them to building your own
                    infrastructure.</p>
            </div>

            <h3>15.5 Chapter Summary</h3>
            <p>Placeholder summarizing common deployment architectures for AI APIs, including containerization (Docker),
                orchestration (Kubernetes), serverless, and managed cloud platforms.</p>

            <div class="chapter-nav">
                <a href="#ch14" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 14</a>
                <a href="#ch16" class="chapter-nav-btn">Next: Chapter 16 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- PART V: CASE STUDIES AND FUTURE DIRECTIONS -->
        <div id="part5" class="mb-6">
            <h1>Part V: Case Studies and Future Directions</h1>
            <p>Apply the concepts learned throughout the book to real-world scenarios and look ahead at the evolving
                landscape of AI APIs.</p>
        </div>

        <!-- CHAPTER 16 -->
        <div id="ch16">
            <h2>Chapter 16: NLP API Case Study <a href="#ch16" class="header-anchor">#</a></h2>
            <p>Build and deploy APIs for common Natural Language Processing tasks, applying Pydantic schemas and FastAPI
                implementation patterns.</p>

            <div id="ch16-1">
                <h3>16.1 Building a Sentiment Analysis API <a href="#ch16-1" class="header-anchor">#</a></h3>
                <p>Placeholder content walking through the design (Pydantic models for request/response) and
                    implementation (FastAPI endpoints, model integration) of a sentiment analysis service.</p>
            </div>

            <div id="ch16-2">
                <h3>16.2 Building a Text Generation API <a href="#ch16-2" class="header-anchor">#</a></h3>
                <p>Placeholder content detailing the creation of an API for text generation, handling parameters like
                    prompts, max tokens, temperature, and structuring the response.</p>
            </div>

            <div id="ch16-3">
                <h3>16.3 Deployment and Scaling Considerations for NLP <a href="#ch16-3" class="header-anchor">#</a>
                </h3>
                <p>Placeholder content discussing specific challenges for deploying NLP models, such as model size,
                    inference latency, and handling different languages.</p>
            </div>

            <h3>16.4 Chapter Summary</h3>
            <p>Placeholder summarizing the practical application of book concepts to building and deploying NLP APIs.
            </p>

            <div class="chapter-nav">
                <a href="#ch15" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 15</a>
                <a href="#ch17" class="chapter-nav-btn">Next: Chapter 17 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 17 -->
        <div id="ch17">
            <h2>Chapter 17: Computer Vision API Case Study <a href="#ch17" class="header-anchor">#</a></h2>
            <p>Explore the development of APIs for computer vision tasks, focusing on handling image data and
                structuring complex outputs.</p>

            <div id="ch17-1">
                <h3>17.1 Building an Object Detection API <a href="#ch17-1" class="header-anchor">#</a></h3>
                <p>Placeholder content showing the design and implementation of an API that accepts an image and returns
                    detected objects with bounding boxes and confidence scores.</p>
            </div>

            <div id="ch17-2">
                <h3>17.2 Building an Image Classification API <a href="#ch17-2" class="header-anchor">#</a></h3>
                <p>Placeholder content detailing an API for image classification, returning top predicted classes and
                    their probabilities.</p>
            </div>

            <div id="ch17-3">
                <h3>17.3 Handling Image Data: Uploads vs. URLs <a href="#ch17-3" class="header-anchor">#</a></h3>
                <p>Placeholder content comparing different ways to accept image input (direct upload, base64 encoding,
                    URL pointers) and their implementation details in FastAPI.</p>
                <div class="note">
                    <p>Placeholder note on using FastAPI's `UploadFile` for direct uploads.</p>
                </div>
            </div>

            <h3>17.4 Chapter Summary</h3>
            <p>Placeholder summarizing the development of computer vision APIs, focusing on data handling and output
                structuring.</p>

            <div class="chapter-nav">
                <a href="#ch16" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 16</a>
                <a href="#ch18" class="chapter-nav-btn">Next: Chapter 18 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 18 -->
        <div id="ch18">
            <h2>Chapter 18: Recommendation System API Case Study <a href="#ch18" class="header-anchor">#</a></h2>
            <p>Design and implement APIs for serving recommendations, considering user context, item data, and real-time
                vs. batch generation.</p>

            <div id="ch18-1">
                <h3>18.1 User-Based and Item-Based Recommendation Endpoints <a href="#ch18-1"
                        class="header-anchor">#</a></h3>
                <p>Placeholder content designing API endpoints like `/users/{user_id}/recommendations` or
                    `/items/{item_id}/similar`, defining appropriate request parameters and response schemas.</p>
            </div>

            <div id="ch18-2">
                <h3>18.2 Handling Context and Personalization <a href="#ch18-2" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing how to incorporate user context (e.g., current session, preferences)
                    into recommendation requests for more personalized results.</p>
            </div>

            <div id="ch18-3">
                <h3>18.3 Real-time vs. Batch Recommendation Generation <a href="#ch18-3" class="header-anchor">#</a>
                </h3>
                <p>Placeholder content comparing architectures where recommendations are generated on-the-fly versus
                    pre-computed and served quickly from a cache or database.</p>
            </div>

            <h3>18.4 Chapter Summary</h3>
            <p>Placeholder summarizing the design and implementation considerations for building recommendation system
                APIs.</p>

            <div class="chapter-nav">
                <a href="#ch17" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 17</a>
                <a href="#ch19" class="chapter-nav-btn">Next: Chapter 19 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 19 -->
        <div id="ch19">
            <h2>Chapter 19: Future Directions and Emerging Trends <a href="#ch19" class="header-anchor">#</a></h2>
            <p>Look ahead at how the field of AI APIs is evolving, including new model types, interaction paradigms, and
                ethical considerations.</p>

            <div id="ch19-1">
                <h3>19.1 APIs for Foundation Models and Generative AI <a href="#ch19-1" class="header-anchor">#</a></h3>
                <p>Placeholder content discussing the specific API design patterns emerging for large language models
                    (LLMs) and other foundation models, including streaming responses and prompt engineering interfaces.
                </p>
            </div>

            <div id="ch19-2">
                <h3>19.2 The Rise of AI Agents and Function Calling <a href="#ch19-2" class="header-anchor">#</a></h3>
                <p>Placeholder content exploring how APIs are becoming tools for AI agents, requiring careful design for
                    "function calling" or tool use capabilities.</p>
            </div>

            <div id="ch19-3">
                <h3>19.3 Ethical Considerations and Responsible AI in APIs <a href="#ch19-3" class="header-anchor">#</a>
                </h3>
                <p>Placeholder content discussing the growing importance of incorporating fairness, transparency, and
                    accountability principles into AI API design and output.</p>
            </div>

            <div id="ch19-4">
                <h3>19.4 Evolving Frameworks and Tools <a href="#ch19-4" class="header-anchor">#</a></h3>
                <p>Placeholder content speculating on future developments in Pydantic, FastAPI, and the broader Python
                    AI/API ecosystem.</p>
            </div>

            <h3>19.5 Chapter Summary</h3>
            <p>Placeholder summarizing emerging trends like foundation model APIs, AI agents, ethical AI considerations,
                and potential future tool developments.</p>

            <div class="chapter-nav">
                <a href="#ch18" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 18</a>
                <a href="#ch20" class="chapter-nav-btn">Next: Chapter 20 <i class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- CHAPTER 20 -->
        <div id="ch20">
            <h2>Chapter 20: Conclusion <a href="#ch20" class="header-anchor">#</a></h2>
            <p>Recap the key principles, techniques, and best practices covered throughout the book for building robust,
                maintainable, and performant AI APIs using Pydantic and modern Python frameworks.</p>

            <h3>Key Takeaways</h3>
            <ul>
                <li>Placeholder: APIs are the standard for AI deployment.</li>
                <li>Placeholder: Pydantic provides essential validation and schema definition.</li>
                <li>Placeholder: FastAPI offers a powerful, modern platform for AI APIs.</li>
                <li>Placeholder: Good design considers inputs, outputs, performance, security, and maintainability.</li>
                <li>Placeholder: Testing, documentation, and robust deployment are critical.</li>
            </ul>

            <h3>Final Thoughts</h3>
            <p>Placeholder content offering final encouragement and emphasizing the importance of continuous learning in
                the rapidly evolving field of AI and API development.</p>

            <div class="chapter-nav">
                <a href="#ch19" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 19</a>
                <a href="#appendix-a" class="chapter-nav-btn">Next: Appendix A <i
                        class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- APPENDICES -->
        <div id="appendices" class="mb-6">
            <h1>Appendices</h1>
        </div>

        <!-- Appendix A -->
        <div id="appendix-a">
            <h2>Appendix A: Pydantic Migration Guide (v1 to v2) <a href="#appendix-a" class="header-anchor">#</a></h2>
            <p>Guidance for migrating existing Pydantic v1 codebases to take advantage of the performance and features
                of Pydantic v2.</p>
            <h3>Key Changes</h3>
            <ul>
                <li>Placeholder: `dict()` -> `model_dump()`</li>
                <li>Placeholder: `json()` -> `model_dump_json()`</li>
                <li>Placeholder: `parse_obj` -> `model_validate()`</li>
                <li>Placeholder: Validator signature changes</li>
                <li>Placeholder: Configuration changes (`Config` class vs. `model_config` dict)</li>
            </ul>
            <div class="code-sample">
                <span class="language-badge">Pydantic v1 vs v2 Example</span>
                <pre><code class="language-python"># Placeholder Pydantic v1 code
# class ModelV1(BaseModel):
#     ...
#     class Config:
#         orm_mode = True
# model_v1.dict()

# Placeholder Pydantic v2 code
# class ModelV2(BaseModel):
#     model_config = ConfigDict(from_attributes=True)
#     ...
# model_v2.model_dump()</code></pre>
            </div>
            <div class="chapter-nav">
                <a href="#ch20" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Chapter 20</a>
                <a href="#appendix-b" class="chapter-nav-btn">Next: Appendix B <i
                        class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- Appendix B -->
        <div id="appendix-b">
            <h2>Appendix B: FastAPI Advanced Features <a href="#appendix-b" class="header-anchor">#</a></h2>
            <p>Explore some of FastAPI's more advanced capabilities beyond the basics covered in Chapter 4.</p>
            <ul>
                <li>Placeholder: WebSocket support</li>
                <li>Placeholder: Advanced Dependency Injection (dependencies with `yield`)</li>
                <li>Placeholder: Middleware</li>
                <li>Placeholder: Custom Response classes</li>
                <li>Placeholder: APIRouter for modular applications</li>
                <li>Placeholder: Background Tasks</li>
                <li>Placeholder: Testing advanced features</li>
            </ul>
            <div class="chapter-nav">
                <a href="#appendix-a" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Appendix
                    A</a>
                <a href="#appendix-c" class="chapter-nav-btn">Next: Appendix C <i
                        class="fas fa-arrow-right ml-2"></i></a>
            </div>
        </div>

        <div class="section-divider"></div>

        <!-- Appendix C -->
        <div id="appendix-c">
            <h2>Appendix C: Configuration Patterns <a href="#appendix-c" class="header-anchor">#</a></h2>
            <p>Dive deeper into managing configuration for your AI APIs, building upon the `pydantic-settings` discussed
                earlier.</p>
            <ul>
                <li>Placeholder: Environment-specific configurations (dev, staging, prod)</li>
                <li>Placeholder: Handling secrets securely (e.g., using environment variables, secret managers)</li>
                <li>Placeholder: Hierarchical configuration</li>
                <li>Placeholder: Dynamic configuration reloading</li>
                <li>Placeholder: Integrating settings with Dependency Injection</li>
            </ul>
            <div class="chapter-nav">
                <a href="#appendix-b" class="chapter-nav-btn"><i class="fas fa-arrow-left mr-2"></i> Previous: Appendix
                    B</a>
                <span></span>
            </div>
        </div>

    </main>

    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/prism.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/components/prism-python.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/components/prism-bash.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/components/prism-json.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/prismjs@1.25.0/components/prism-docker.min.js"></script>
    <!-- Added Dockerfile syntax highlighting -->

    <script>
        // Theme toggling
        const themeToggle = document.getElementById('theme-toggle');
        const body = document.body;
        const icon = themeToggle.querySelector('i');

        // Check for saved theme preference or use preferred color scheme
        const savedTheme = localStorage.getItem('theme');
        const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;

        function applyTheme(theme) {
            if (theme === 'dark') {
                body.classList.add('dark-mode');
                icon.classList.remove('fa-moon');
                icon.classList.add('fa-sun');
                // Ensure Prism theme matches
                document.querySelector('link[href*="prism-tomorrow"]').href = 'https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism-tomorrow.min.css';
            } else {
                body.classList.remove('dark-mode');
                icon.classList.remove('fa-sun');
                icon.classList.add('fa-moon');
                // Ensure Prism theme matches - using a light theme, e.g., prism.css
                document.querySelector('link[href*="prism-tomorrow"]').href = 'https://cdn.jsdelivr.net/npm/prismjs@1.25.0/themes/prism.min.css'; // Change to a light theme if desired
            }
        }

        if (savedTheme) {
            applyTheme(savedTheme);
        } else {
            applyTheme(prefersDark ? 'dark' : 'light');
        }

        themeToggle.addEventListener('click', () => {
            const currentTheme = body.classList.contains('dark-mode') ? 'light' : 'dark';
            applyTheme(currentTheme);
            localStorage.setItem('theme', currentTheme);
        });

        // Mobile navigation toggle
        const mobileNavToggle = document.getElementById('mobile-nav-toggle');
        const sidebar = document.getElementById('sidebar');

        mobileNavToggle.addEventListener('click', () => {
            sidebar.classList.toggle('sidebar-open');
        });

        // Close sidebar when clicking outside on mobile
        document.addEventListener('click', (e) => {
            if (window.innerWidth <= 768 &&
                !sidebar.contains(e.target) &&
                !mobileNavToggle.contains(e.target) &&
                sidebar.classList.contains('sidebar-open')) {
                sidebar.classList.remove('sidebar-open');
            }
        });

        // Add copy buttons to code blocks
        document.querySelectorAll('pre > code').forEach(codeBlock => {
            const pre = codeBlock.parentNode;
            if (pre.querySelector('.copy-btn')) return; // Avoid adding multiple buttons

            const button = document.createElement('button');
            button.className = 'copy-btn';
            button.innerHTML = '<i class="fas fa-copy"></i> Copy'; // Use icon + text

            pre.style.position = 'relative'; // Ensure pre is positioned for absolute button
            pre.appendChild(button);

            button.addEventListener('click', () => {
                const code = codeBlock.innerText;
                navigator.clipboard.writeText(code).then(() => {
                    button.innerHTML = '<i class="fas fa-check"></i> Copied!';
                    setTimeout(() => {
                        button.innerHTML = '<i class="fas fa-copy"></i> Copy';
                    }, 2000);
                }).catch(err => {
                    button.textContent = 'Failed!';
                    console.error('Failed to copy text: ', err);
                });
            });
        });

        // Search functionality simulation
        const searchBox = document.getElementById('search-box');
        searchBox.addEventListener('input', (e) => {
            const query = e.target.value.toLowerCase();
            // Basic simulation: log the search query
            if (query) {
                console.log(`Simulating search for: ${query}`);
                // In a real app, you would filter sidebar links or page content here.
                // Example: Highlight matching nav items (very basic)
                document.querySelectorAll('.nav-item').forEach(item => {
                    if (item.textContent.toLowerCase().includes(query)) {
                        item.style.backgroundColor = 'rgba(25, 118, 210, 0.1)'; // Highlight
                    } else {
                        item.style.backgroundColor = ''; // Reset
                    }
                });
            } else {
                document.querySelectorAll('.nav-item').forEach(item => {
                    item.style.backgroundColor = ''; // Reset all highlights
                });
            }
        });
        searchBox.addEventListener('focus', () => {
            searchBox.placeholder = 'Search... (simulation)';
        });
        searchBox.addEventListener('blur', () => {
            searchBox.placeholder = 'Search...';
        });

        // Reading progress bar
        const progressBar = document.getElementById('progress-bar');
        const mainContent = document.querySelector('.main-content');

        function updateProgressBar() {
            if (!mainContent) return;
            const contentHeight = mainContent.scrollHeight;
            const viewportHeight = window.innerHeight;
            // Adjust scrollable height calculation if body scrolls instead of mainContent
            const scrollableHeight = document.documentElement.scrollHeight - viewportHeight;
            const scrollTop = window.scrollY || document.documentElement.scrollTop;

            const progress = scrollableHeight > 0 ? (scrollTop / scrollableHeight) * 100 : 0;
            progressBar.style.width = `${Math.min(progress, 100)}%`;
        }

        window.addEventListener('scroll', updateProgressBar);
        window.addEventListener('resize', updateProgressBar); // Recalculate on resize
        document.addEventListener('DOMContentLoaded', updateProgressBar); // Initial calculation


        // Active link highlighting based on scroll position (more advanced)
        const sections = document.querySelectorAll('.main-content > div[id]'); // Target top-level divs with IDs
        const navLinks = document.querySelectorAll('.sidebar .nav-item');

        function updateActiveLink() {
            let currentSectionId = '';
            const scrollPosition = window.scrollY + (window.innerHeight / 3); // Offset to activate link sooner

            sections.forEach(section => {
                const sectionTop = section.offsetTop - 70; // Adjust for header/padding
                const sectionHeight = section.offsetHeight;
                if (scrollPosition >= sectionTop && scrollPosition < sectionTop + sectionHeight) {
                    currentSectionId = section.getAttribute('id');
                }
            });

            // If no section is actively in view (e.g., at the very top/bottom), fallback needed
            if (!currentSectionId && sections.length > 0) {
                // Maybe default to first visible section or handle top/bottom cases
                if (window.scrollY < sections[0].offsetTop) {
                    // currentSectionId = sections[0].getAttribute('id'); // Optionally activate first section
                } else if (window.scrollY + window.innerHeight >= document.documentElement.scrollHeight - 10) { // Near bottom
                    currentSectionId = sections[sections.length - 1].getAttribute('id');
                }
            }


            navLinks.forEach(link => {
                link.classList.remove('active');
                const href = link.getAttribute('href');
                if (href && href.substring(1) === currentSectionId) {
                    link.classList.add('active');
                    // Optional: Expand parent if child is active
                    const parentNav = link.closest('.child-nav');
                    if (parentNav) {
                        const parentLink = parentNav.previousElementSibling;
                        if (parentLink && parentLink.classList.contains('nav-item')) {
                            // You might add a class to the parent link or section title here
                        }
                    }
                }
                // Special case for introduction section at top
                if (currentSectionId === 'introduction' && href === '#introduction') {
                    link.classList.add('active');
                }
            });
        }


        window.addEventListener('scroll', updateActiveLink);
        document.addEventListener('DOMContentLoaded', updateActiveLink);


        // Scroll to anchor smoothly & Update Active Link Manually on Click
        document.querySelectorAll('.sidebar a.nav-item, .toc-item a').forEach(anchor => {
            anchor.addEventListener('click', function (e) {
                const href = this.getAttribute('href');
                if (href && href.startsWith('#')) {
                    e.preventDefault();

                    const targetId = href.substring(1);
                    const targetElement = document.getElementById(targetId);

                    if (targetElement) {
                        const offsetTop = targetElement.offsetTop - 60; // Adjust for fixed header/navbar
                        window.scrollTo({
                            top: offsetTop,
                            behavior: 'smooth'
                        });

                        // Manually update active class immediately on click
                        document.querySelectorAll('.nav-item').forEach(item => {
                            item.classList.remove('active');
                        });
                        // Try finding the exact link first
                        let clickedNavLink = document.querySelector(`.sidebar a.nav-item[href="${href}"]`);
                        if (clickedNavLink) {
                            clickedNavLink.classList.add('active');
                        } else {
                            // Fallback for cases where ID matches but href might be slightly different (e.g. TOC links)
                            // This part might need refinement depending on exact structure
                            clickedNavLink = document.querySelector(`.sidebar a.nav-item[href="#${targetId}"]`);
                            if (clickedNavLink) clickedNavLink.classList.add('active');
                        }


                        // Update URL hash without causing page jump AFTER smooth scroll (optional)
                        // setTimeout(() => { history.pushState(null, null, href); }, 800); // Adjust delay as needed

                        // Close sidebar on mobile after navigation
                        if (window.innerWidth <= 768 && sidebar.classList.contains('sidebar-open')) {
                            sidebar.classList.remove('sidebar-open');
                        }
                    }
                }
            });
        });

        // Add header anchors automatically
        document.querySelectorAll('.main-content h2[id], .main-content h3[id], .main-content h4[id]').forEach(header => {
            const id = header.getAttribute('id');
            if (id) {
                const anchorLink = document.createElement('a');
                anchorLink.href = `#${id}`;
                anchorLink.className = 'header-anchor';
                anchorLink.innerHTML = '<i class="fas fa-link fa-xs"></i>'; // Smaller link icon
                anchorLink.setAttribute('aria-label', `Link to section: ${header.textContent.trim()}`);
                header.appendChild(anchorLink);
            }
        });

        // Dynamically build TOC based on H2/H3 in main content (More robust than static list)
        function buildTOC() {
            const tocContainer = document.querySelector('.table-of-contents');
            if (!tocContainer) return; // No TOC container found

            // Clear existing TOC items except title
            const tocTitle = tocContainer.querySelector('.toc-title');
            tocContainer.innerHTML = ''; // Clear all content
            if (tocTitle) tocContainer.appendChild(tocTitle); // Add title back

            const headers = document.querySelectorAll('.main-content h2[id], .main-content h3[id]');
            headers.forEach(header => {
                const level = header.tagName === 'H2' ? 1 : 2; // Assuming H2 is level 1, H3 is level 2
                const id = header.getAttribute('id');
                const title = header.textContent.replace(/#$/, '').trim(); // Remove trailing # if present

                if (id && title) {
                    const tocItem = document.createElement('div');
                    tocItem.classList.add('toc-item');
                    if (level === 2) tocItem.classList.add('toc-level-2');
                    if (level === 3) tocItem.classList.add('toc-level-3'); // Add level 3 if needed

                    const link = document.createElement('a');
                    link.href = `#${id}`;
                    link.textContent = title;
                    tocItem.appendChild(link);
                    tocContainer.appendChild(tocItem);
                }
            });

            // Re-attach smooth scroll to new TOC links
            document.querySelectorAll('.toc-item a').forEach(anchor => {
                anchor.addEventListener('click', function (e) {
                    // Copied smooth scroll logic from above...
                    const href = this.getAttribute('href');
                    if (href && href.startsWith('#')) {
                        e.preventDefault();
                        const targetId = href.substring(1);
                        const targetElement = document.getElementById(targetId);
                        if (targetElement) {
                            const offsetTop = targetElement.offsetTop - 60;
                            window.scrollTo({ top: offsetTop, behavior: 'smooth' });
                        }
                    }
                });
            });
        }

        document.addEventListener('DOMContentLoaded', buildTOC);


    </script>
</body>

</html>